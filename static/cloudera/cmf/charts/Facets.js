// (c) Copyright 2012 Cloudera, Inc. All rights reserved.
define([
  "underscore",
  "knockout",
  "komapping",
  "cloudera/common/I18n",
  "cloudera/cmf/charts/Plot"
], function(_, ko, komapping, I18n, Plot) {

  /**
   * Computes facets from time series data.
   *
   * options : {
   *   container: "selector or the DOM element"
   *   plot: the plot object
   * }
   */
  function Facets(options) {
    var self = this;

    function clickFacetGroup(vm, event) {
      self.selectedFacet(this.name());

      if (event) {
        event.preventDefault();
      }
    }

    self.facets = ko.observableArray();
    var innerSelectedFacet = ko.observable(options.plot.facetting || Plot.FACETTING_NONE);
    self.selectedFacet = ko.computed({
      read: function() {
        return innerSelectedFacet();
      },
      write: function(value) {
        innerSelectedFacet(value);
        $.publish("clickFacetGroup", [value]);
      }
    }, self);

    /**
     * Updates the facets data.
     */
    self.update = function(timeSeriesArray) {
      self.cleanup(timeSeriesArray);
      var facetsData = self.computeFacets(timeSeriesArray);

      self.facets.removeAll();

      if (facetsData.length === 0) {
        return;
      }
      // Put this at the beginning.
      facetsData.unshift({
        name: Plot.FACETTING_NONE,
        // This is not the same as other facets,
        // but it is a good approximation for now.
        counts: timeSeriesArray
      });

      // Put this at the end.
      facetsData.push({
        name: Plot.FACETTING_SINGLE_PLOT,
        // This is not the same as other facets,
        // but it is a good approximation for now.
        counts: [{}]
      });

      // Don't go through KO array methods since we are doing a lot of
      // array manipulation. We'll notify observers at the end.
      var underlyingFacetsArray = self.facets();
      _.each(facetsData, function(data) {
        var facet = {
          name: ko.observable(data.name),
          counts: ko.observable(data.counts)
        };
        var displayName = facet.name();
        // Still translate the two default facets that begin with __:
        // __no_facetting__ or __single_plot__
        if (displayName && displayName.indexOf("__") === 0) {
          displayName = I18n.t("ui.facet." + facet.name());
        }
        facet.displayName = ko.observable(displayName);
        facet.click = _.bind(clickFacetGroup, facet);
        facet.selected = ko.observable(facet.name() === self.selectedFacet());
        underlyingFacetsArray.push(facet);
      });
      self.facets.valueHasMutated();
    };

    /**
     * Some attributes are not appropriate to be shown
     * in the facets panel.
     */
    self.cleanup = function(timeSeriesArray) {
      _.each(timeSeriesArray, function(timeSeries) {
        if (timeSeries.metadata && timeSeries.metadata.attributes) {
          // These two attributes are too long.
          delete timeSeries.metadata.attributes.roleName;
          delete timeSeries.metadata.attributes.entityName;
        }
      });
    };

    /**
     * The function expects a dictionary generated by computeFacets, an attribute
     * name and an attribute value. If necessary it will add the attribute name
     * and value to the facets data. In any case it will increase the count by one.
     */
    self.addFacetAttribute = function(facetData, attributeName, attributeValue) {
      if (_.isEmpty(attributeName) || _.isEmpty(attributeValue)) {
        // nothing to do
        return;
      }
      if (!facetData.hasOwnProperty(attributeName)) {
        facetData[attributeName] = {};
      }
      if (!facetData[attributeName].hasOwnProperty(attributeValue)) {
        facetData[attributeName][attributeValue] = 0;
      }
      facetData[attributeName][attributeValue]++;
    };

    /**
     * Given [ {
     *     data: [{x:...,y:...},...],
     *     metadata: {
     *       attributes: {
     *         k:v
     *       }
     *     }
     *   } ]
     * } ],
     *
     * return [ {
     *   name: k,
     *   counts: {
     *     value: v,
     *     count: count(k, v)
     *   }
     * },
     *
     * For example, input = [ {
     *   data: [{x:1,y:1}],
     *   metadata: {
     *     attributes: {
     *       roleType: "DATANODE",
     *       serviceType: "HDFS"
     *     }
     *   }
     * }, {
     *   data: [{x:1,y:1}],
     *   metadata: {
     *     attributes: {
     *       roleType: "DATANODE",
     *       hostName: "localhost"
     *     }
     *   }
     * }, {
     *   data: [{x:1,y:1}],
     *   metadata: {
     *     attributes: {
     *       roleType: "NAMENODE",
     *       hostName: "localhost"
     *   }
     * } ]
     *
     * This function should return
     * [ {
     *   name: "roleType",
     *   counts: [ {
     *     value: "DATANODE",
     *     count: 2
     *   }, {
     *     value: "NAMENODE",
     *     count: 1
     *   } ]
     * }, {
     *   name: "hostName",
     *   counts: [ {
     *     value: "localhost",
     *     count: 2
     *   } ]
     * }, {
     *   name: "serviceType",
     *   counts: [ {
     *     value: "HDFS",
     *     count: 1
     *   } ]
     * } ]
     *
     */
    self.computeFacets = function(timeSeriesArray) {
      var ret = {};
      _.each(timeSeriesArray, function(timeSeries) {
        if (timeSeries.metadata) {
          _.each(timeSeries.metadata.attributes, function(v, k) {
                self.addFacetAttribute(ret, k, v);
          });
          // Special handle the metric display name and
          // the entity display name.
          self.addFacetAttribute(ret, "entityDisplayName", timeSeries.metadata.entityDisplayName);
          self.addFacetAttribute(ret, "metricDisplayName", timeSeries.metadata.metricDisplayName);
        }
      });

      // The variable ret now equal to
      // {
      //   k: {
      //     v: count(k, v)
      //   }
      // }
      //
      // In the example above, ret now equal to
      // {
      //   "roleType":{
      //     "DATANODE":2,
      //     "NAMENODE":1
      //   },
      //   "serviceType":{
      //     "HDFS":1
      //   },
      //   "hostName":{
      //     "localhost":2
      //   }
      // }
      //
      // Now convert to the final output format:
      // [ {
      //   name: k,
      //   counts: {
      //     value: v,
      //     count: count(k, v)
      //   }
      // };
      // vcount below represents { v: count(k, v) }
      return _.chain(ret).map(function(vcount, k) {
        return {
          name: k,
          counts: _.chain(vcount)
            .map(function(count, v) {
              return {
                value: v,
                count: count
              };
            })
            .sortBy(function(o) {
              // descending by count
              return -o.count;
            })
            .value()
        };
      }).sortBy(function(o) {
        // secondary sort on name,
        return o.name;
      }).sortBy(function(o) {
        // primary sort on o.counts
        return -o.counts.length;
      }).value();
    }; // computeFacets

    if (options.container) {
      ko.applyBindings(self, $(options.container)[0]);
    }
  }

  return Facets;
});

